<!DOCTYPE html>
<html lang="en">
  <head>
  
    <script src="//code.jquery.com/jquery-1.10.2.js"></script>
    <script> 
    $(function(){
      $("#navbar").load("navbar.html");
      $("#footer").load("footer.html"); 
    });
    </script>

    <script type='text/javascript'>//<![CDATA[
      $(window).load(function(){
      $('.dropdown-menu').click(function(e) {
        e.stopPropagation();
      });
      });//]]> 
    </script>

    <!-- To set the correct width in abstract and bibtex dropdowns -->
    <script>
      function getWidth(){
        var width = document.getElementById("navbar").clientWidth/2 + "px";
	var widthStr = "width: " + width + ";";
        var abstracts = document.getElementsByClassName("abstract");
        var bibtexes = document.getElementsByClassName("bibtex");
        for(var i = 0; i < abstracts.length; i++){
          abstracts[i].setAttribute("style", widthStr);
        }

	for(var i = 0; i < bibtexes.length; i++){
          bibtexes[i].setAttribute("style", widthStr);
        }
      }

      window.onload=function() {
        getWidth();
      }
    </script>


    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="favicon.png">

    <title>Alexandra Pinto Castellanos</title>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">


    <!-- Custom styles for this template -->
    <link href="assets/css/main.css" rel="stylesheet">
    <!-- Custom styles for this page -->
    <link href="assets/css/publications.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="assets/js/hover.zoom.js"></script>
    <script src="assets/js/hover.zoom.conf.js"></script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <!-- Static navbar -->
    <div id="navbar"></div>

    <div class="container">
      <div class="row">
        <div class="offset1 span8">
          </br>

<!--------------------------------------->
<!--           JOURNAL PAPERS          -->
<!--------------------------------------->
<h3>Journal Papers</h3>
  </br>
  <hr>
  <!-- ---------NEW ENTRY AFTER THIS LINE---------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Alexandra Pinto Castellanks <b>(2018)</b> </br> 
                                <b> Stochastic Resonance in Neural Network, Noise Color Effects</b></br> 
In <i>Energies</i> </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Some systems cannot be predicted by classical theories and require the development of combined deterministic and stochastic theories that make use of noise for their dynamical prediction. Noise is not always an interfering signal which perturbs the system, it can also enhance its performance. This property can be observed through Stochastic Resonance (SR), To detect this phenomena it is necessary a system with bistable potential barrier with a threshold, the input of the system should be a weak periodic signal which amplitude is below threshold together with a stochastic signal. The behaviour of the SR is detected in a neural network and it is studied under noise color variations. Here it is found that Pink noise amplifies the sub-threshold input signal twenty times more in comparison to white noise. This could be evidence of the functionality of background noise in the brain, where neurons are naturally embedded in pink noise.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{energies_dem,
    abstract = { Some systems cannot be predicted by classical theories and require the development of combined deterministic and stochastic theories that make use of noise for their dynamical prediction. Noise is not always an interfering signal which perturbs the system, it can also enhance its performance. This property can be observed through Stochastic Resonance (SR), To detect this phenomena it is necessary a system with bistable potential barrier with a threshold, the input of the system should be a weak periodic signal which amplitude is below threshold together with a stochastic signal. The behaviour of the SR is detected in a neural network and it is studied under noise color variations. Here it is found that Pink noise amplifies the sub-threshold input signal twenty times more in comparison to white noise. This could be evidence of the functionality of background noise in the brain, where neurons are naturally embedded in pink noise.},
    author = {Pinto Alexandra},
    doi = {10.13140/RG.2.2.25576.26887},
    openaccess = {arXiv:1810.06731v3},
    pdf = {https://www.academia.edu/37518013/Stochastic_Resonance_in_neural_network_noise_color_effects},
    title = {Stochastic Resonance in Neural Network, Noise Color Effects},
    year = {2018}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://www.mdpi.com/1996-1073/13/9/2409"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://www.mdpi.com/1996-1073/13/9/2409/pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Conte, A. and De Sensi, D. and Grossi, R. and Marino, A. and Versari, L. <b>(2020)</b> </br> 
                                <b>Truly Scalable K-Truss and Max-Truss Algorithms for Community Detection in Graphs</b></br> 
In <i>IEEE Access</i>, pp. 1-14 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               The notion of k-truss has been introduced a decade ago in social network analysis and security for  community  detection,  as  a  form  of  cohesive  subgraphs  less  stringent  than  a  clique  (set  of  pairwise linked nodes), and more selective than a k-core (induced subgraph with minimum degreek). A k-truss is an inclusion-maximal subgraph H in which each edge belongs to at least k−2 triangles inside H. The truss decomposition establishes, for each edge e, the maximum k for which e belongs to a k-truss. Analogously to the largest clique and to the maximum k-core, the strongest community for k-truss is the max-truss, which corresponds to the k-truss having the maximum k. Even though the computation of truss decomposition and of the max-truss takes polynomial time, on a large scale, it suffers from handling a potentially cubic number of wedges. In this paper, we provide a new algorithm FMT, which advances the state of the art on different sides: lower execution time, lower memory usage, and no need for expensive hardware. We compare FMT experimentally with the most recent state-of-the-art algorithms on a set of large real-world and synthetic networks with over a billion edges. The massive improvement allows FMT to compute the max-truss of networks of tens of billions of edges on a single standard server machine.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{9146824,
    abstract = {The notion of k-truss has been introduced a decade ago in social network analysis and security for  community  detection,  as  a  form  of  cohesive  subgraphs  less  stringent  than  a  clique  (set  of  pairwise linked nodes), and more selective than a k-core (induced subgraph with minimum degreek). A k-truss is an inclusion-maximal subgraph H in which each edge belongs to at least k−2 triangles inside H. The truss decomposition establishes, for each edge e, the maximum k for which e belongs to a k-truss. Analogously to the largest clique and to the maximum k-core, the strongest community for k-truss is the max-truss, which corresponds to the k-truss having the maximum k. Even though the computation of truss decomposition and of the max-truss takes polynomial time, on a large scale, it suffers from handling a potentially cubic number of wedges. In this paper, we provide a new algorithm FMT, which advances the state of the art on different sides: lower execution time, lower memory usage, and no need for expensive hardware. We compare FMT experimentally with the most recent state-of-the-art algorithms on a set of large real-world and synthetic networks with over a billion edges. The massive improvement allows FMT to compute the max-truss of networks of tens of billions of edges on a single standard server machine.},
    author = {Conte, A. and De Sensi, D. and Grossi, R. and Marino, A. and Versari, L.},
    doi = {10.1109/ACCESS.2020.3011667},
    issn = {2169-3536},
    journal = {IEEE Access},
    number = {},
    openaccess = {https://ieeexplore.ieee.org/document/9146824},
    pages = {1-14},
    title = {Truly Scalable K-Truss and Max-Truss Algorithms for Community Detection in Graphs},
    volume = {},
    year = {2020}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://ieeexplore.ieee.org/document/9146824"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Rinaldi, Luca and Torquati, Massimo and De Sensi, Daniele and Mencagli, Gabriele and Danelutto, Marco <b>(2020)</b> </br> 
                                <b>Improving the performance of Actors on Multi-Cores with Parallel Patterns</b></br> 
In <i>International Journal of Parallel Programming</i> </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Griebler, Dalvan
and Vogel, Adriano
and De Sensi, Daniele
and Danelutto, Marco
and Fernandes, Luiz G. <b>(2019)</b> </br> 
                                <b>Simplifying and implementing service level objectives for stream parallelism</b></br> 
In <i>The Journal of Supercomputing</i>, pp. 1-26 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Matteis, Tiziano and Mencagli, Gabriele and De Sensi, Daniele and Torquati, Massimo and Danelutto, Marco <b>(2019)</b> </br> 
                                <b>GASSER: An Auto-Tunable System for General Sliding-Window Streaming Operators on GPUs</b></br> 
In <i>IEEE Access</i>, pp. 48753-48769 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele and De Matteis, Tiziano and Danelutto, Marco <b>(2018)</b> </br> 
                                <b>Simplifying self-adaptive and power-aware computing with Nornir</b></br> 
In <i>Future Generation Computer Systems</i>, pp.  -  </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Torquati, Massimo and De Sensi, Daniele and Mencagli, Gabriele and Aldinucci, Marco and Danelutto, Marco <b>(2018)</b> </br> 
                                <b>Power-aware pipelining with automatic concurrency control</b></br> 
In <i>Concurrency and Computation: Practice and Experience</i>, pp. e4652 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Danelutto, Marco
and De Matteis, Tiziano
and De Sensi, Daniele
and Mencagli, Gabriele
and Torquati, Massimo
and Aldinucci, Marco
and Kilpatrick, Peter <b>(2017)</b> </br> 
                                <b>The RePhrase Extended Pattern Set for Data Intensive Parallel Computing</b></br> 
In <i>International Journal of Parallel Programming</i>, pp. 74–93 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               We discuss the extended parallel pattern set identified within the EU-funded project RePhrase as a candidate pattern set to support data intensive applications targeting heterogeneous architectures. The set has been designed to include three classes of pattern, namely (1) core patterns, modelling common, not necessarily data intensive parallelism exploitation patterns, usually to be used in composition; (2) high level patterns, modelling common, complex and complete parallelism exploitation patterns; and (3) building block patterns, modelling the single components of data intensive applications, suitable for use---in composition---to implement patterns not covered by the core and high level patterns. We discuss the expressive power of the RePhrase extended pattern set and results illustrating the performances that may be achieved with the FastFlow implementation of the high level patterns.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{rephrase:ijpp17,
    abstract = {We discuss the extended parallel pattern set identified within the EU-funded project RePhrase as a candidate pattern set to support data intensive applications targeting heterogeneous architectures. The set has been designed to include three classes of pattern, namely (1) core patterns, modelling common, not necessarily data intensive parallelism exploitation patterns, usually to be used in composition; (2) high level patterns, modelling common, complex and complete parallelism exploitation patterns; and (3) building block patterns, modelling the single components of data intensive applications, suitable for use---in composition---to implement patterns not covered by the core and high level patterns. We discuss the expressive power of the RePhrase extended pattern set and results illustrating the performances that may be achieved with the FastFlow implementation of the high level patterns.},
    author = {Danelutto, Marco
and De Matteis, Tiziano

                                <!-- Paper information -->
                                De Sensi, Daniele and Torquati, Massimo and Danelutto, Marco <b>(2017)</b> </br> 
                                <b>Mammut: High-level management of system knobs and sensors</b></br> 
In <i>SoftwareX</i>, pp. 150 - 154 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Managing low-level architectural features for controlling performance and power consumption is a growing demand in the parallel computing community. Such features include, but are not limited to: energy profiling, platform topology analysis, CPU cores disabling and frequency scaling. However, these low-level mechanisms are usually managed by specific tools, without any interaction between each other, thus hampering their usability. More important, most existing tools can only be used through a command line interface and they do not provide any API. Moreover, in most cases, they only allow monitoring and managing the same machine on which the tools are used. Mammut provides and integrates architectural management utilities through a high-level and easy-to-use object-oriented interface. By using Mammut, is possible to link together different collected information and to exploit them on both local and remote systems, to build architecture-aware applications.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{mammut:softwarex,
    abstract = {Managing low-level architectural features for controlling performance and power consumption is a growing demand in the parallel computing community. Such features include, but are not limited to: energy profiling, platform topology analysis, CPU cores disabling and frequency scaling. However, these low-level mechanisms are usually managed by specific tools, without any interaction between each other, thus hampering their usability. More important, most existing tools can only be used through a command line interface and they do not provide any API. Moreover, in most cases, they only allow monitoring and managing the same machine on which the tools are used. Mammut provides and integrates architectural management utilities through a high-level and easy-to-use object-oriented interface. By using Mammut, is possible to link together different collected information and to exploit them on both local and remote systems, to build architecture-aware applications.},
    author = {De Sensi, Daniele and Torquati, Massimo and Danelutto, Marco},
    doi = {http://dx.doi.org/10.1016/j.softx.2017.06.005},
    issn = {2352-7110},
    journal = {SoftwareX},
    keywords = {Energy profiling},
    month = {jul},
    note = {},
    number = {},
    openaccess = {http://www.sciencedirect.com/science/article/pii/S2352711017300225},
    pages = {150 - 154},
    title = {Mammut: High-level management of system knobs and sensors},
    url = {http://www.sciencedirect.com/science/article/pii/S2352711017300225},
    volume = {6},
    year = {2017}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://www.sciencedirect.com/science/article/pii/S2352711017300225"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele and De Matteis, Tiziano and Torquati, Massimo and Mencagli, Gabriele and Danelutto, Marco <b>(2017)</b> </br> 
                                <b>Bringing Parallel Patterns Out of the Corner: The P<sup>3</sup>ARSEC Benchmark Suite</b></br> 
In <i>ACM Trans. Archit. Code Optim.</i>, pp. 33:1--33:26 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               High-level parallel programming is an active research topic aimed at promoting parallel programming methodologies that provide the programmer with high-level abstractions to develop complex parallel software with reduced time to solution. Pattern-based parallel programming is based on a set of composable and customizable parallel patterns used as basic building blocks in parallel applications. In recent years, a considerable effort has been made in empowering this programming model with features able to overcome shortcomings of early approaches concerning flexibility and performance. In this article, we demonstrate that the approach is flexible and efficient enough by applying it on 12 out of 13 PARSEC applications. Our analysis, conducted on three different multicore architectures, demonstrates that pattern-based parallel programming has reached a good level of maturity, providing comparable results in terms of performance with respect to both other parallel programming methodologies based on pragma-based annotations (i.e., Openmp and OmpSs) and native implementations (i.e., Pthreads). Regarding the programming effort, we also demonstrate a considerable reduction in lines of code and code churn compared to Pthreads and comparable results with respect to other existing implementations.
                               </i> 

<!-- ---------ENTRY START--------- -->

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele and Torquati, Massimo and Danelutto, Marco <b>(2016)</b> </br> 
                                <b>A Reconfiguration Algorithm for Power-Aware Parallel Applications</b></br> 
In <i>ACM Transactions on Architecture and Code Optimization</i>, pp. 43:1--43:25 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               In current computing systems, many applications require guarantees on their maximum power consumption to not exceed the available power budget. On the other hand, for some applications, it could be possible to decrease their performance, yet maintaining an acceptable level, in order to reduce their power consumption. To provide such guarantees, a possible solution consists in changing the number of cores assigned to the application, their clock frequency and the placement of application threads over the cores. However, power consumption and performance have different trends depending on the application considered and on its input. Finding a configuration of resources satisfying user requirements is in the general case a challenging task.
In this paper we propose Nornir, an algorithm to automatically derive, without relying on historical data about previous executions, performance and power consumption models of an application in different configurations. By using these models, we are able to select a close to optimal configuration for the given user requirement, either performance or power consumption. The configuration of the application will be changed on-the-fly throughout the execution to adapt to workload fluctuations, external interferences and/or application's phase changes. We validate the algorithm by simulating it over the applications of the PARSEC benchmark suite. Then, we implement our algorithm and we analyse its accuracy and overhead over some of these applications on a real execution environment. Eventually, we compare the quality of our proposal with that of the optimal algorithm and of some state of the art solutions.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{nornir:taco16,
    abstract = {In current computing systems, many applications require guarantees on their maximum power consumption to not exceed the available power budget. On the other hand, for some applications, it could be possible to decrease their performance, yet maintaining an acceptable level, in order to reduce their power consumption. To provide such guarantees, a possible solution consists in changing the number of cores assigned to the application, their clock frequency and the placement of application threads over the cores. However, power consumption and performance have different trends depending on the application considered and on its input. Finding a configuration of resources satisfying user requirements is in the general case a challenging task.
In this paper we propose Nornir, an algorithm to automatically derive, without relying on historical data about previous executions, performance and power consumption models of an application in different configurations. By using these models, we are able to select a close to optimal configuration for the given user requirement, either performance or power consumption. The configuration of the application will be changed on-the-fly throughout the execution to adapt to workload fluctuations, external interferences and/or application's phase changes. We validate the algorithm by simulating it over the applications of the PARSEC benchmark suite. Then, we implement our algorithm and we analyse its accuracy and overhead over some of these applications on a real execution environment. Eventually, we compare the quality of our proposal with that of the optimal algorithm and of some state of the art solutions.},
    acmid = {3004054},
    address = {New York, NY, USA},
    articleno = {43},
    author = {De Sensi, Daniele and Torquati, Massimo and Danelutto, Marco},
    doi = {10.1145/3004054},
    issn = {1544-3566},
    issue_date = {December 2016},
    journal = {ACM Transactions on Architecture and Code Optimization},
    keywords = {DVFS, Power-aware computing, dynamic concurrency throttling, multi-core, online learning, power capping, self-adaptive runtime},
    month = {December},
    number = {4},
    numpages = {25},
    openaccess = {http://dl.acm.org/authorize?N34888},
    pages = {43:1--43:25},
    pdf = {assets/pdf/2016_TACO.pdf},
    publisher = {ACM},
    slides = {https://docs.google.com/presentation/d/1-3zD8pe75mWFA9vbvNgKhwqVMg7jC8ari34inUQwEyE/edit?usp=sharing},
    title = {A Reconfiguration Algorithm for Power-Aware Parallel Applications},
    url = {http://doi.acm.org/10.1145/3004054},
    videopitch = {https://www.youtube.com/watch?v=ckm-Zu8cLdA&feature=youtu.be},
    volume = {13},
    year = {2016}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://dl.acm.org/authorize?N34888"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2016_TACO.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Video Pitch button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://www.youtube.com/watch?v=ckm-Zu8cLdA&feature=youtu.be"> 
                               Video 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1-3zD8pe75mWFA9vbvNgKhwqVMg7jC8ari34inUQwEyE/edit?usp=sharing"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Brogi, Antonio and Danelutto, Marco and De Sensi, Daniele and Ibrahim, Ahmad and Soldani, Jacopo and Torquati, Massimo <b>(2016)</b> </br> 
                                <b>Analysing Multiple QoS Attributes in Parallel Design Patterns-Based Applications</b></br> 
In <i>International Journal of Parallel Programming</i>, pp. 1--20 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Parallel design patterns can be fruitfully combined to develop parallel software applications. Different combinations of patterns can feature different QoS while being functionally equivalent. To support application developers in selecting the best combinations of patterns to develop their applications, we hereby propose a probabilistic approach that permits analysing, at design time, multiple QoS attributes of parallel design patterns-based application. We also present a proof-of-concept implementation of our approach, together with some experimental results.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @article{pasa:ijpp16,
    abstract = {Parallel design patterns can be fruitfully combined to develop parallel software applications. Different combinations of patterns can feature different QoS while being functionally equivalent. To support application developers in selecting the best combinations of patterns to develop their applications, we hereby propose a probabilistic approach that permits analysing, at design time, multiple QoS attributes of parallel design patterns-based application. We also present a proof-of-concept implementation of our approach, together with some experimental results.},
    author = {Brogi, Antonio and Danelutto, Marco and De Sensi, Daniele and Ibrahim, Ahmad and Soldani, Jacopo and Torquati, Massimo},
    doi = {10.1007/s10766-016-0476-8},
    issn = {1573-7640},
    journal = {International Journal of Parallel Programming},
    month = {november},
    openaccess = {http://rdcu.be/yK2u},
    pages = {1--20},
    pdf = {assets/pdf/2016_IJPP.pdf},
    title = {Analysing Multiple QoS Attributes in Parallel Design Patterns-Based Applications},
    url = {http://dx.doi.org/10.1007/s10766-016-0476-8},
    year = {2016}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://rdcu.be/yK2u"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2016_IJPP.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!--------------------------------------->
<!--            CONF PAPERS            -->
<!--------------------------------------->
<h3>Conference and Workshops Papers</h3>
  </br>
  <hr>
  <!-- ---------NEW ENTRY AFTER THIS LINE---------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele
and Danelutto, Marco <b>(2020)</b> </br> 
                                <b>Application-Aware Power Capping Using Nornir</b></br> 
In <i>Parallel Processing and Applied Mathematics</i>, pp. 191--202 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Power consumption of IT infrastructure is a major concern for data centre operators. Since data centres power supply is usually dimensioned for an average-case scenario, uncorrelated and simultaneous power spikes in multiple servers could lead to catastrophic effects such as power outages. To avoid such situations, power capping solutions are usually put in place by data centre operators, to control power consumption of individual server and to avoid the datacenter exceeding safe operational limits. However, most power capping solutions rely on Dynamic Voltage and Frequency Scaling (DVFS), which is not always able to guarantee the power cap specified by the user, especially for low power budget values. In this work, we propose a power-capping algorithm that uses a combination of DVFS and Thread Packing. We implement this algorithm in the Nornir framework and we validate it on some real applications by comparing it to the Intel RAPL power capping algorithm and another state of the art power capping algorithm.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{ppam2019,
    abstract = {Power consumption of IT infrastructure is a major concern for data centre operators. Since data centres power supply is usually dimensioned for an average-case scenario, uncorrelated and simultaneous power spikes in multiple servers could lead to catastrophic effects such as power outages. To avoid such situations, power capping solutions are usually put in place by data centre operators, to control power consumption of individual server and to avoid the datacenter exceeding safe operational limits. However, most power capping solutions rely on Dynamic Voltage and Frequency Scaling (DVFS), which is not always able to guarantee the power cap specified by the user, especially for low power budget values. In this work, we propose a power-capping algorithm that uses a combination of DVFS and Thread Packing. We implement this algorithm in the Nornir framework and we validate it on some real applications by comparing it to the Intel RAPL power capping algorithm and another state of the art power capping algorithm.},
    address = {Cham},
    author = {De Sensi, Daniele
and Danelutto, Marco},
    booktitle = {Parallel Processing and Applied Mathematics},
    doi = {10.1007/978-3-030-43222-5_17},
    editor = {Wyrzykowski, Roman
and Deelman, Ewa
and Dongarra, Jack
and Karczewski, Konrad},
    isbn = {978-3-030-43222-5},
    pages = {191--202},
    pdf = {assets/pdf/2019_PPAM.pdf},
    publisher = {Springer International Publishing},
    slides = {https://docs.google.com/presentation/d/1pIPrQk3HWW5zhdGM1ywM2o7AGbV_TOHfGkMSwfmqtcM/edit?usp=sharing},
    title = {Application-Aware Power Capping Using Nornir},
    url = {https://link.springer.com/chapter/10.1007/978-3-030-43222-5_17},
    year = {2020}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://link.springer.com/chapter/10.1007/978-3-030-43222-5_17"> 
                               Published Version 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2019_PPAM.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1pIPrQk3HWW5zhdGM1ywM2o7AGbV_TOHfGkMSwfmqtcM/edit?usp=sharing"> 
                               Slides 
                               </a> 

</br></br>
<hr>

    publisher = {Springer International Publishing},
    slides = {https://docs.google.com/presentation/d/1GyUVj0YvF3tQhKH_zQEsM4_stQcR5srvUxHQsR8xfBk/edit?usp=sharing},
    title = {Transparent Autonomicity for OpenMP Applications},
    url = {https://link.springer.com/chapter/10.1007%2F978-3-030-48340-1_5},
    year = {2020}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://link.springer.com/chapter/10.1007%2F978-3-030-48340-1_5"> 
                               Published Version 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2019_AutoDasp.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1GyUVj0YvF3tQhKH_zQEsM4_stQcR5srvUxHQsR8xfBk/edit?usp=sharing"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele and Di Girolamo, Salvatore and Hoefler, Torsten <b>(2019)</b> </br> 
                                <b>Mitigating Network Noise on Dragonfly Networks Through Application-aware Routing</b></br> 
In <i>Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</i>, pp. 16:1--16:32 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               System noise can negatively impact the performance of HPC systems, and the interconnection network is one of the main factors contributing to this problem. To mitigate this effect, adaptive routing sends packets on non-minimal paths if they are less congested. However, while this may mitigate interference caused by congestion, it also generates more traffic since packets traverse additional hops, causing in turn congestion on other applications and on the application itself. In this paper, we first describe how to estimate network noise. By following these guidelines, we show how noise can be reduced by using routing algorithms which select minimal paths with a higher probability. We exploit this knowledge to design an algorithm which changes the probability of selecting minimal paths according to the application characteristics. We validate our solution on microbenchmarks and real-world applications on two systems relying on a Dragonfly interconnection network, showing noise reduction and performance improvement.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{sc2019,
    abstract = {System noise can negatively impact the performance of HPC systems, and the interconnection network is one of the main factors contributing to this problem. To mitigate this effect, adaptive routing sends packets on non-minimal paths if they are less congested. However, while this may mitigate interference caused by congestion, it also generates more traffic since packets traverse additional hops, causing in turn congestion on other applications and on the application itself. In this paper, we first describe how to estimate network noise. By following these guidelines, we show how noise can be reduced by using routing algorithms which select minimal paths with a higher probability. We exploit this knowledge to design an algorithm which changes the probability of selecting minimal paths according to the application characteristics. We validate our solution on microbenchmarks and real-world applications on two systems relying on a Dragonfly interconnection network, showing noise reduction and performance improvement.},
    acmid = {3356196},
    address = {New York, NY, USA},
    articleno = {16},
    artifacts_available = {},
    author = {De Sensi, Daniele and Di Girolamo, Salvatore and Hoefler, Torsten},
    booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
    doi = {10.1145/3295500.3356196},
    isbn = {978-1-4503-6229-0},
    keywords = {dragonfly, network noise, routing},
    location = {Denver, Colorado},
    numpages = {32},
    openaccess = {https://dl.acm.org/authorize?N690645},
    pages = {16:1--16:32},
    pdf = {assets/pdf/2019_SC.pdf},
    publisher = {ACM},
    series = {SC '19},

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Structured parallel programming models based on parallel design patterns are gaining more and more importance. Several state-of-the-art industrial frameworks build on the  parallel design pattern concept, including Intel TBB and Microsoft PPL. In these frameworks, the explicit exposition of parallel structure of the application favours the identification of the inefficiencies, the exploitation of techniques increasing the efficiency of the implementation and ensures that most of the more critical aspects related to an efficient exploitation of the available parallelism are moved from application programmers to framework designers.
The very same exposition of the graph representing the parallel activities enables framework designers to emplace efficient autonomic management of non functional concerns, such as performance tuning or power management.
In this paper, we discuss how autonomic management features evolved in different structured parallel programming frameworks based on the algorithmic skeletons and parallel design patterns.
We show that different levels of autonomic management are possible, ranging from simple provisioning of mechanisms suitable to support programmers in the implementation of ad hoc autonomic managers to the complete autonomic managers whose behaviour may be programmed using high level rules by the application programmers. 
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{hpcs2019,
    abstract = {Structured parallel programming models based on parallel design patterns are gaining more and more importance. Several state-of-the-art industrial frameworks build on the  parallel design pattern concept, including Intel TBB and Microsoft PPL. In these frameworks, the explicit exposition of parallel structure of the application favours the identification of the inefficiencies, the exploitation of techniques increasing the efficiency of the implementation and ensures that most of the more critical aspects related to an efficient exploitation of the available parallelism are moved from application programmers to framework designers.
The very same exposition of the graph representing the parallel activities enables framework designers to emplace efficient autonomic management of non functional concerns, such as performance tuning or power management.
In this paper, we discuss how autonomic management features evolved in different structured parallel programming frameworks based on the algorithmic skeletons and parallel design patterns.
We show that different levels of autonomic management are possible, ranging from simple provisioning of mechanisms suitable to support programmers in the implementation of ad hoc autonomic managers to the complete autonomic managers whose behaviour may be programmed using high level rules by the application programmers. },
    address = {Dublin, Ireland},
    author = {Danelutto, Marco and De Sensi, Daniele and Mencagli, Gabriele and Torquati, Massimo},
    booktitle = {High Performance Computing Simulation (HPCS), 2019 International Conference on},
    month = {July},
    pdf = {assets/pdf/2019_HPCS.pdf},
    title = {Autonomic Management Experiences in Structured Parallel Programming},
    toappear = {},
    year = {2019}
}


                                   </div> 
                                   </div> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2019_HPCS.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- To appear button --> 
                               <a class="btn btn-primary rightmargin" style="float: left;background-color:red;border-color:red"> 
                               To Appear 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Conte, Alessio and De Sensi, Daniele and Grossi, Roberto and Marino, Andrea and Versari, Luca <b>(2018)</b> </br> 
                                <b>Discovering k-Trusses in Large-Scale Networks</b></br> 
In <i>2018 IEEE High Performance extreme Computing Conference (HPEC)</i>, pp. 1-6 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               A k-truss is a subgraph where every edge belongs to at least k-2 triangles in the subgraph. The truss decomposition assigns each edge the maximum k for which the edge belongs to a k-truss, and the trussness of a graph is the maximum among its edges. Discovery algorithms for k-trusses and truss decomposition provide useful insight for graph analytics (such as community detection). Even though they take polynomial time, on massive networks they suffer from handling a potentially cubic number of wedges: algorithms either need a long time to recompute triangles several times, have high memory usage, or rely on the large number of cores on graphic units. In this paper we describe EXTRUS, a highly optimized algorithm for truss decomposition which outperforms existing algorithms. We then introduce a faster algorithm, HYBTRUS, which finds the trussness of a graph using less time and space than EXTRUSS. Our algorithms take the best of existing approaches having good performance, low memory usage, and no need for sophisticated hardware systems.
We compare our algorithms with the state-of-the-art on a set of real-world and synthetic networks. EXTRUSS processes graphs with over a billion edges, which seems difficult for the competitors, and our HYBTRUSS is the first algorithm able to find the trussness of a graph with over 25 billion edges.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Griebler, Dalvan and De Sensi, Daniele and Vogel, Adriano and Danelutto, Marco and Fernandes, Luiz Gustavo <b>(2019)</b> </br> 
                                <b>Service Level Objectives via C++11 Attributes</b></br> 
In <i>Euro-Par 2018: Parallel Processing Workshops</i>, pp. 745--756 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               In recent years, increasing attention has been given to the possibility of guaranteeing Service Level Objectives (SLOs) to users about their applications, either regarding performance or power consumption. SLO can be implemented for parallel applications since they can provide many control knobs (e.g., the number of threads to use, the clock frequency of the cores, etc.) to tune the performance and power consumption of the application. Different from most of the existing approaches, we target sequential stream processing applications by proposing a solution based on C++ annotations. The user specifies which parts of the code to parallelize and what type of requirements should be enforced on that part of the code. Our solution first automatically parallelizes the annotated code and then applies self-adaptation approaches at run-time to enforce the user-expressed objectives. We ran experiments on different real-world applications, showing its simplicity and effectiveness.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{spar:nornir,
    abstract = {In recent years, increasing attention has been given to the possibility of guaranteeing Service Level Objectives (SLOs) to users about their applications, either regarding performance or power consumption. SLO can be implemented for parallel applications since they can provide many control knobs (e.g., the number of threads to use, the clock frequency of the cores, etc.) to tune the performance and power consumption of the application. Different from most of the existing approaches, we target sequential stream processing applications by proposing a solution based on C++ annotations. The user specifies which parts of the code to parallelize and what type of requirements should be enforced on that part of the code. Our solution first automatically parallelizes the annotated code and then applies self-adaptation approaches at run-time to enforce the user-expressed objectives. We ran experiments on different real-world applications, showing its simplicity and effectiveness.},
    address = {Cham},
    author = {Griebler, Dalvan and De Sensi, Daniele and Vogel, Adriano and Danelutto, Marco and Fernandes, Luiz Gustavo},
    booktitle = {Euro-Par 2018: Parallel Processing Workshops},
    isbn = {978-3-030-10549-5},
    pages = {745--756},
    pdf = {assets/pdf/2018_REPARA.pdf},
    publisher = {Springer International Publishing},
    slides = {https://docs.google.com/presentation/d/1dv0mdCjP-n0QIDFoEiX61I2mCdLpFE0EFbWdaJZ0iEA/edit?usp=sharing},
    title = {Service Level Objectives via C++11 Attributes},
    url = {https://link.springer.com/chapter/10.1007%2F978-3-030-10549-5_58},
    year = {2019}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://link.springer.com/chapter/10.1007%2F978-3-030-10549-5_58"> 
                               Published Version 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2018_REPARA.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1dv0mdCjP-n0QIDFoEiX61I2mCdLpFE0EFbWdaJZ0iEA/edit?usp=sharing"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Vogel, Adriano
and Griebler, Dalvan
and De Sensi, Daniele
and Danelutto, Marco
and Fernandes, Luiz Gustavo <b>(2019)</b> </br> 
                                <b>Autonomic and Latency-Aware Degree of Parallelism Management in SPar</b></br> 
In <i>Euro-Par 2018: Parallel Processing Workshops</i>, pp. 28--39 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Conte, Alessio and De Matteis, Tiziano and De Sensi, Daniele and Grossi, Roberto and Marino, Andrea and Versari, Luca <b>(2018)</b> </br> 
                                <b>D2K: Scalable Community Detection in Massive Networks via Small-Diameter k-Plexes</b></br> 
In <i>Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery \&\#38; Data Mining</i>, pp. 1272--1281 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               This paper studies kplexes, a well known pseudo-clique model for network communities. In a kplex, each node can miss at most $k-1$ links. Our goal is to detect large communities in today's real-world graphs which can have hundreds of millions of edges. While many have tried, this task has been elusive so far due to its computationally challenging nature: kplexes and other pseudo-cliques are harder to find and more numerous than cliques, a well known hard problem. We present D2K, which is the first algorithm able to find large kplexes of very large graphs in just a few minutes. The good performance of our algorithm follows from a combination of graph-theoretical concepts, careful algorithm engineering and a high-performance implementation. In particular, we exploit the low degeneracy of real-world graphs, and the fact that large enough kplexes have diameter~2. We validate a sequential and a parallel/distributed implementation of D2K on real graphs with up to half a billion edges.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{kdd:18,
    abstract = {This paper studies kplexes, a well known pseudo-clique model for network communities. In a kplex, each node can miss at most $k-1$ links. Our goal is to detect large communities in today's real-world graphs which can have hundreds of millions of edges. While many have tried, this task has been elusive so far due to its computationally challenging nature: kplexes and other pseudo-cliques are harder to find and more numerous than cliques, a well known hard problem. We present D2K, which is the first algorithm able to find large kplexes of very large graphs in just a few minutes. The good performance of our algorithm follows from a combination of graph-theoretical concepts, careful algorithm engineering and a high-performance implementation. In particular, we exploit the low degeneracy of real-world graphs, and the fact that large enough kplexes have diameter~2. We validate a sequential and a parallel/distributed implementation of D2K on real graphs with up to half a billion edges.},
    acmid = {3220093},
    address = {New York, NY, USA},
    author = {Conte, Alessio and De Matteis, Tiziano and De Sensi, Daniele and Grossi, Roberto and Marino, Andrea and Versari, Luca},
    booktitle = {Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery \&\#38; Data Mining},
    doi = {10.1145/3219819.3220093},
    isbn = {978-1-4503-5552-0},
    keywords = {community discovery, graph enumeration, k-plexes, parallel programming},
    location = {London, United Kingdom},
    numpages = {10},
    openaccess = {https://dl.acm.org/authorize?N666390},
    pages = {1272--1281},
    pdf = {assets/pdf/2018_KDD.pdf},
    publisher = {ACM},
    series = {KDD '18},
    title = {D2K: Scalable Community Detection in Massive Networks via Small-Diameter k-Plexes},
    url = {http://doi.acm.org/10.1145/3219819.3220093},
    videopitch = {https://www.youtube.com/watch?v=zF2Hz1wq9eM},
    year = {2018}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://dl.acm.org/authorize?N666390"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2018_KDD.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Video Pitch button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://www.youtube.com/watch?v=zF2Hz1wq9eM"> 
                               Video 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Torquati, Massimo and Menga, Tullio and De Matteis, Tiziano and De Sensi, Daniele and Mencagli, Gabriele <b>(2018)</b> </br> 
                                <b>Reducing Message Latency and CPU Utilization in the CAF Actor Framework</b></br> 
In <i>2018 26th Euromicro International Conference on Parallel, Distributed and Network-based Processing (PDP)</i>, pp. 145-153 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               In this work, we consider the C++ Actor Framework (CAF), a recent proposal that revamped the interest in building concurrent and distributed applicaions using the actor programming model in C++. CAF has been optimized for high-throughput computing, whereas message latency between actors is greatly influenced by the message data rate: at low and moderate rates the latency is higher than at high data rates. To this end, we propose a modification of the polling strategies in the work-stealing CAF scheduler, which can reduce message latency at low and moderate data rates up to two orders of magnitude without compromising the overall throughput and message latency at maximum pressure. The technique proposed uses a lightweight event notification protocol that is general enough to be used used to optimize the runtime of other frameworks experiencing similar issues.
                               </i> 
                               </div> 
                               </div> 

<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele
and De Matteis, Tiziano
and Danelutto, Marco <b>(2018)</b> </br> 
                                <b>Nornir: A Customizable Framework for Autonomic and Power-Aware Applications</b></br> 
In <i>Euro-Par 2017: Parallel Processing Workshops</i>, pp. 42--54 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               A desirable characteristic of modern parallel applications is the ability to dynamically select the amount of resources to be used to meet requirements on performance or power consumption. In many cases, providing explicit guarantees on performance is of paramount importance. In streaming applications, this is related with the concept of elasticity, i.e. being able to allocate the proper amount of resources to match the current demand as closely as possible. Similarly, in other scenarios, it may be useful to limit the maximum power consumption of an application to do not exceed the power budget. In this paper we propose Nornir, a customizable C++ framework for autonomic and power-aware parallel applications on shared memory multicore machines. Nornir can be used by autonomic strategy designers to implement new algorithms and by application users to enforce requirements on applications.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{nornir:autodasp17,
    abstract = {A desirable characteristic of modern parallel applications is the ability to dynamically select the amount of resources to be used to meet requirements on performance or power consumption. In many cases, providing explicit guarantees on performance is of paramount importance. In streaming applications, this is related with the concept of elasticity, i.e. being able to allocate the proper amount of resources to match the current demand as closely as possible. Similarly, in other scenarios, it may be useful to limit the maximum power consumption of an application to do not exceed the power budget. In this paper we propose Nornir, a customizable C++ framework for autonomic and power-aware parallel applications on shared memory multicore machines. Nornir can be used by autonomic strategy designers to implement new algorithms and by application users to enforce requirements on applications.},
    author = {De Sensi, Daniele
and De Matteis, Tiziano
and Danelutto, Marco},
    booktitle = {Euro-Par 2017: Parallel Processing Workshops},
    doi = {10.1007/978-3-319-75178-8_4},
    editor = {Heras, Dora B.
and Bouge, Luc},
    isbn = {978-3-319-75178-8},
    pages = {42--54},
    pdf = {assets/pdf/2017_AutoDasp.pdf},
    publisher = {Springer International Publishing},
    slides = {https://docs.google.com/presentation/d/1PJ9gn_jIdApjrK1-wB3gnAB2PPYOsocxrqMTB96HI2E/edit?usp=sharing},
    title = {Nornir: A Customizable Framework for Autonomic and Power-Aware Applications},
    url = {https://link.springer.com/chapter/10.1007/978-3-319-75178-8_42},
    year = {2018}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://link.springer.com/chapter/10.1007/978-3-319-75178-8_42"> 
                               Published Version 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2017_AutoDasp.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1PJ9gn_jIdApjrK1-wB3gnAB2PPYOsocxrqMTB96HI2E/edit?usp=sharing"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->




                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://dl.acm.org/authorize?N34889"> 
                               Published Version <b>(Open Access)</b> 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2017_SAC.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://docs.google.com/presentation/d/1tbGK13EGookcV1HvVbup2Rx1HlH65t4tsbhIuaoS3tA/edit#slide=id.g1b7a7fa945_0_14"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                De Sensi, Daniele <b>(2016)</b> </br> 
                                <b>Predicting Performance and Power Consumption of Parallel Applications</b></br> 
In <i>Proceedings of 24th Euromicro International Conference on Parallel, Distributed, and Network-Based Processing (PDP)</i>, pp. 200 -- 207 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Current architectures provide many control knobs for the reduction of power consumption of applications, like reducing the number of used cores or scaling down their frequency. However, choosing the right values for these knobs in order to satisfy requirements on performance and/or power consumption is a complex task and trying all the possible combinations of these values is an unfeasible solution since it would require too much time. For this reasons, there is the need for techniques that allow an accurate estimation of the performance and power consumption of an application when a specific configuration of the control knobs values is used. Usually, this is done by executing the application with different configurations and by using these information to predict its behaviour when the values of the knobs are changed. However, since this is a time consuming process, we would like to execute the application in the fewest number of configurations possible. In this work, we consider as control knobs the number of cores used by the application and the frequency of these cores. We show that on most Parsec benchmark programs, by executing the application in 1% of the total possible configurations and by applying a multiple linear regression model we are able to achieve an average accuracy of 96% in predicting its execution time and power consumption in all the other possible knobs combinations.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{models:pdp:16,
    abstract = {Current architectures provide many control knobs for the reduction of power consumption of applications, like reducing the number of used cores or scaling down their frequency. However, choosing the right values for these knobs in order to satisfy requirements on performance and/or power consumption is a complex task and trying all the possible combinations of these values is an unfeasible solution since it would require too much time. For this reasons, there is the need for techniques that allow an accurate estimation of the performance and power consumption of an application when a specific configuration of the control knobs values is used. Usually, this is done by executing the application with different configurations and by using these information to predict its behaviour when the values of the knobs are changed. However, since this is a time consuming process, we would like to execute the application in the fewest number of configurations possible. In this work, we consider as control knobs the number of cores used by the application and the frequency of these cores. We show that on most Parsec benchmark programs, by executing the application in 1% of the total possible configurations and by applying a multiple linear regression model we are able to achieve an average accuracy of 96% in predicting its execution time and power consumption in all the other possible knobs combinations.},
    author = {De Sensi, Daniele},
    booktitle = {Proceedings of 24th Euromicro International Conference on Parallel, Distributed, and Network-Based Processing ({PDP})},
    doi = {10.1109/PDP.2016.41},
    keywords = {Power-aware computing; Regression analysis; PARSEC benchmark; Control knobs; DVFS; Predictive models; Concurrency throttling;},
    month = {Feb},
    pages = {200 -- 207},
    pdf = {assets/pdf/2016_PDP.pdf},
    slides = {https://drive.google.com/open?id=1tl5DcBySHfA8A7eQhpxykiqofOCVee308VDAomUTHLQ},
    title = {Predicting Performance and Power Consumption of Parallel Applications},
    url = {http://ieeexplore.ieee.org/document/7445331/},
    year = {2016}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://ieeexplore.ieee.org/document/7445331/"> 
                               Published Version 
                               </a> 

<!-- Preprint pdf button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="assets/pdf/2016_PDP.pdf"> 
                               PDF <b>(Preprint)</b> 
                               </a> 

<!-- Slides button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="https://drive.google.com/open?id=1tl5DcBySHfA8A7eQhpxykiqofOCVee308VDAomUTHLQ"> 
                               Slides 
                               </a> 

</br></br>
<hr>
<!-- ---------ENTRY END--------- -->
<!-- ---------ENTRY START--------- -->
                                <!-- Paper information -->
                                Danelutto, Marco and De Sensi, Daniele and Torquati, Massimo <b>(2015)</b> </br> 
                                <b>Energy driven adaptivity in stream parallel computations</b></br> 
In <i>Proceedings of 23th Euromicro International Conference on Parallel, Distributed, and Network-Based Processing (PDP)</i>, pp. 103 -- 110 </br> 

<!-- Dropdown Abstract --> 
                               <div class="dropdown" style="float: left"> 
                               <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                               Abstract 
                               <span class="caret"></span> 
                               </a> 
                               <div class="abstract dropdown-menu" role="menu" aria-labelledby="dLabel"> 
                               <i> 
                               Determining the right amount of resources needed for a given computation is a critical problem. In many cases, computing systems are configured to use an amount of resources to manage high load peaks even though this cause energy waste when the resources are not fully utilised. To avoid this problem, adaptive approaches are used to dynamically increase/decrease computational resources depending on the real needs. A different approach based on Dynamic Voltage and Frequency Scaling (DVFS) is emerging as a possible alternative solution to reduce energy consumption of idle CPUs by lowering their frequencies. In this work, we propose to tackle the problem in stream parallel computations by using both the classic adaptivity concepts and the possibility provided by modern CPUs to dynamically change their frequency. We validate our approach showing a real network application that performs Deep Packet Inspection over network traffic. We are able to manage bandwidth changing over time, guaranteeing minimal packet loss during reconfiguration and minimal energy consumption.
                               </i> 
                               </div> 
                               </div> 

<!-- Dropdown Bibtex --> 
                                   <div class="dropdown" style="float: left"> 
                                   <a class="btn btn-primary dropdown-toggle rightmargin" data-toggle="dropdown" href="#"> 
                                   BibTeX 
                                   <span class="caret"></span> 
                                   </a> 
                                   <div class="bibtex dropdown-menu" role="menu" aria-labelledby="dLabel">                                   @inproceedings{ff:energy:pdp:15,
    abstract = {Determining the right amount of resources needed for a given computation is a critical problem. In many cases, computing systems are configured to use an amount of resources to manage high load peaks even though this cause energy waste when the resources are not fully utilised. To avoid this problem, adaptive approaches are used to dynamically increase/decrease computational resources depending on the real needs. A different approach based on Dynamic Voltage and Frequency Scaling (DVFS) is emerging as a possible alternative solution to reduce energy consumption of idle CPUs by lowering their frequencies. In this work, we propose to tackle the problem in stream parallel computations by using both the classic adaptivity concepts and the possibility provided by modern CPUs to dynamically change their frequency. We validate our approach showing a real network application that performs Deep Packet Inspection over network traffic. We are able to manage bandwidth changing over time, guaranteeing minimal packet loss during reconfiguration and minimal energy consumption.},
    address = {Turku, Finland},
    author = {Danelutto, Marco and De Sensi, Daniele and Torquati, Massimo},
    booktitle = {Proceedings of 23th Euromicro International Conference on Parallel, Distributed, and Network-Based Processing ({PDP})},
    date-added = {2015-02-28 10:59:38 +0000},
    date-modified = {2015-02-28 11:01:23 +0000},
    doi = {10.1109/PDP.2015.92},
    issn = {1066-6192},
    keywords = {fastflow, stream parallel, energy consumption, power-aware computing},
    pages = {103 -- 110},
    pdf = {assets/pdf/2015_PDP.pdf},
    publisher = {IEEE},
    slides = {https://drive.google.com/open?id=1b9am66LlxC4b1tKtocbh_dv7BMxCbVNoO-_lYKDcprc},
    title = {Energy driven adaptivity in stream parallel computations},
    url = {http://ieeexplore.ieee.org/document/7092707/},
    year = {2015}
}


                                   </div> 
                                   </div> 

<!-- Download button --> 
                               <a class="btn btn-primary rightmargin" style="float: left" target="_blank" href="http://ieeexplore.ieee.org/document/7092707/"> 
                               Published Version 
                               </a> 


<!-- ---------ENTRY END--------- -->
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div id="footer">
    </div>
	
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="assets/js/bootstrap.min.js"></script>
  </body>
</html>
